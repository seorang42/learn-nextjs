# learn-nextjs
"한 입 크기로 잘라먹는 Next.js(v15)" 강의를 수강하며 배운 내용을 정리한 공간입니다.

강의 링크 : [https://inf.run/EvrS5](https://inf.run/kx4Pe)

- 0-1. 강의 소개
    
    페이지 라우터 : Next 초창기부터 제공되어 오던 구 버전의 라우터
    
    → 단점을 개선 →
    
    앱 라우터 : Next 13버전과 함께 처음으로 공개된 신규 라우터, 다양한 신규 기능이 제공됨(서버 컴포넌트 등 …), 아직은 과도기
    

- 1-1. Next.js를 소개합니다
    
    React.js 전용 웹 개발 “프레임워크”, React.js를 보다 더 강력하고 편하게 사용할 수 있는 기능들을 제공 ⇒ React.js의 확장판
    
    프레임워크와 라이브러리의 차이
    
    - 기능 구현의 주도권 : 프레임워크가 가짐 → 자유도가 낮다 ⇒ 거의 모든 기능을 제공 / 개발자가 가짐 → 자유도가 높다 ⇒ 기본 기능 외 제공 X
- 1-2. Next.js 사전 렌더링 이해하기
    
    Client Side Rendering(CSR) : React.js 앱의 기본적인 렌더링 방식. 클라이언트(브라우저)에서 직접 화면을 렌더링 하는 방식
    
    - 진행 과정 : 접속 요청 → index.html(빈 껍데기) 전송 → 빈 화면 렌더링(사용자는 아무 것도 없는 페이지 확인) → JS Bundle 전송 → 브라우저가 JS 실행 → 컨텐츠 렌더링 → 화면이 표시됨
    - 페이지 이동 요청 시 : (… 렌더링 과정 후) → 페이지 이동 요청 → 브라우저가 JS 실행 → 페이지 교체
    - 장점 : 초기에 모든 페이지에 필요한 내용을 JS Bundle로 전부 전달받음 ⇒ 페이지 이동이 매우 빠르고 쾌적
    - 단점 : 요청의 시작 시점으로부터 화면에 실제로 표시되기까지 오랜 시간이 걸림 ⇒ 초기 접속 속도(FCP: First Contentful Paint)가 느림,
    
    사전 렌더링 : 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식 ↔ 클라이언트 사이드 렌더링의 단점을 효율적으로 해결
    
    - 진행 과정 : 접속 요청 → JS 실행 (렌더링) → 렌더링된 HTML 전송 → 화면에 렌더링 (화면이 보임 ⇒ FCP 빠름, 하지만 이벤트 핸들링과 같은 상호작용은 불가능) → JS Bundle 전송 → Hydration (HTML과 연결) → 상호작용 가능(TTI : Time To Interactive 측정)
    - Hydration : 상호작용이 불가능한 HTML에 JS를 연결해서 상호작용이 가능하게 하는 작업
    - 페이지 이동 요청 시 : (… 렌더링 과정 후) → 페이지 이동 요청 → 브라우저가 JS 실행(컴포넌트 교체)→ 페이지 교체 ⇒ Next.js도 Hydration으JS Bundle을 전송받기 때문에 클라이언트 사이드 렌더링 방식으로 처리
    - 장점 : 빠른 FCP 달성(React의 단점 개선), 빠른 페이지 이동(React의 장점 승계)
    
    렌더링
    
    - 서버 측 : 자바스크립트 코드(React 컴포넌트)를 HTML로 변환하는 과정
    - 클라이언트 측 : HTML 코드를 브라우저가 화면에 그려내는 작업

- 2-1. Page Router를 소개합니다
    
    현재 많은 기업에서 사용되고 있는 안정적인 라우터. React Router처럼 페이지 라우팅 기능을 제공. pages 폴더의 파일명/폴더명 기준으로 라우팅
    
    동적 경로 : [id].js와 같이 설정 가능
    
    _app.tsx : 모든 페이지 컴포넌트의 부모(루트) 컴포넌트, page 컴포넌트와 해당 컴포넌트의 props를 props로 전달받음. 어떤 페이지를 렌더링하든 _app 안에서 생성됨 ⇒ 글로벌적으로 표시되어야 할 요소 추가 가능
    
    _document.tsx : 모든 페이지에 공통적으로 적용이 되어야 하는 HTML 코드. 메타 태그, 폰트, charset 등을 설정
    
    next.config.mjs : next의 설정 파일
    
- 2-2. 페이지 라우팅 설정하기
    
    useRouter
    
    - next/router - Page Router에서 사용
    - next/navigation - App Router에서 사용
    - 쿼리 스트링을 읽어오면서 컴포넌트를 리렌더링 : 없다가 → 생김
    
    URL Parameter : 동적 경로에 사용되는 가변적인 값
    
    Catch All Segment : 경로 상에 /로 구분되는 모든 값에 대응하는 라우팅 방식. […id].tsx와 같이 설정. /12/123/1234 → { id : [”12”, “123”, “1234”] }로 전달됨. 아무 것도 전달되지 않는 index로 접속할 경우 404 발생
    
    Optional Catch All Segment : [[…id]].tsx와 같이 설정. 아무 URL Parameter가 전달되지 않는 경우에도 대응
    
    404.tsx : 404 not found일 경우 표시되는 페이지
    
- 2-3. 네비게이팅
    
    a 태그 : 클라이언트 사이드 렌더링이 아닌 일반적인 서버 요청을 통한 페이지 이동이 일어남 ⇒ 비교적 느림
    
    Link 컴포넌트 : next에서 클라이언트 사이드 렌더링 방식으로 페이지 이동이 일어날 수 있게 도와주는 컴포넌트
    
    Programmatic Navigation : 사용자가 링크를 직접적으로 클릭해 이동시키는 것이 아닌 특정 행동을 통해 라우팅이 일어나는 것
    
- 2-4. 프리페칭
    
    프리페칭 : 페이지를 사전에 미리 불러오는 작업, 현재 사용자가 보고 있는 페이지 내에서 이동할 가능성이 있는 모든 페이지들을 미리 불러와두는 것
    
    초기 로딩 이후 모든 페이지의 번들 파일을 전달할 경우, 용량이 커지고 Hydration이 늦어짐 ⇒ Next.js는 모든 리액트 컴포넌트들을 페이지 별로 분류해서 저장하기 때문, JS Bundle이 전달될 때 모든 페이지가 아닌, 현재 페이지에 필요한 JS Bundle만 전송 → 이후 페이지 이동 시 속도를 높이기 위해 Pre-Fetching을 동시에 사용
    
    프리페칭은 프로덕션 환경에서만 작동
    
    Programmatic Naviagation은 기본적으로 프리페칭 대상이 되지 않음 ⇒ router.prefetch(”/test”);와 같이 필요한 페이지를 직접 프리페칭할 수 있음
    
    Link 컴포넌트의 prefetch props를 false로 설정하면, 잘 이동하지 않을 것으로 예상되는 페이지의 프리페칭을 비활성화 할 수 있음
    
- 2-5. API Routes
    
    Next.js에서 API를 구축할 수 있게 해주는 기능
    
    /api 폴더 내에 API 구현 가능
    
- 2-6. 스타일링
    
    Next.js는 클래스 네임의 충돌을 방지하기 위해 app 컴포넌트 이외에서 global css 파일의 import를 차단함
    
    ⇒ CSS Module 사용 : 클래스 이름의 충돌을 막기 위해 클래스명을 파일마다 고유한 이름으로 변환해주는 기능. index.module.css와 같이 파일명 설정
    
- 2-8. 페이지별 레이아웃 설정하기
    
    getLayout 메서드를 통해 레이아웃을 설정하는 이유 : return문에 직접적으로 페이지별 레이아웃을 설정하는 경우, 페이지 이동 시 같은 레이아웃을 사용하는 페이지로 이동하더라도 레이아웃 컴포넌트가 언마운트 되었다가 다시 마운트되는 문제가 발생하기 때문입니다. 메서드를 사용하면 App 컴포넌트는 페이지가 이동되더라도 리렌더링되지 않기 때문에 불필요한 레이아웃의 리렌더링을 방지할 수 있습니다.
    
- 2-10. 사전 렌더링과 데이터페칭
    
    기존의 데이터 페칭 방식
    
    1. 불러온 데이터를 보관할 state 생성
    2. 데이터 페칭 함수 생성 : fetch → setState
    3. 컴포넌트 마운트 시점에 fetchData 호출 (!! 데이터 요청 자체가 늦은 시점)
    4. 데이터 로딩 중일 때의 예외 처리
    
    ⇒ 초기 접속 요청부터 데이터 로딩까지 오랜 시간이 걸림 (늦은 FCP 이후 또 데이터 페칭 발생 → 사용자 경험 저하)
    
    Next.js의 경우 사전 렌더링 과정에서 필요한 데이터를 불러오도록 설정할 수 있음 → CSR보다 빠른 시점에 API 호출이 발생 ⇒ 데이터 페칭이 완료된 페이지를 즉시 화면에 표시할 수 있음
    
    ⇒ SSR
    
    서버에서 데이터 페칭에 오랜 시간이 걸린다면? ⇒ 페이지 요청 시점이 아닌, 빌드 시점에 데이터를 가져와 속도를 향상
    
    ⇒ SSG
    
    Next.js의 다양한 사전 렌더링
    
    - 서버사이드 렌더링(SSR) : 가장 기본적인 사전 렌더링 방식, 요청이 들어올 때마다 사전 렌더링을 진행함
    - 정적 사이트 생성(SSG) : 빌드 타임에 미리 페이지를 사전 렌더링 해 둠
    - 증분 정적 재생성(ISR)
- 2-11. SSR 1. 소개 및 실습
    
    가장 기본적인 사전 렌더링 방식, 브라우저에 접속 요청이 발생할 때마다 사전 렌더링을 진행하는 방식
    
    getServerSideProps 함수를 실행시키면 페이지 컴포넌트보다 먼저 실행되어서 사전 렌더링을 진행함
    
    페이지 접속 요청 → getServerSideProps 실행 → 페이지 컴포넌트 실행
    
    getServerSideProps는 props라는 객체 프로퍼티를 포함하는 단 하나의 객체를 반환해야 함 → 페이지 컴포넌트의 props로 전달됨
    
    getServerSideProps는 서버 측에서 딱 한 번만 실행됨
    
    페이지 컴포넌트 또한 서버 측에서 한번 실행됨 → 브라우저에서 Hydration이 일어날 때 한번 더 실행됨
    
    InferGetServerSidePropsType<typeof getServerSideProps> : SSR의 반환값의 타입을 자동으로 추론해주는 Next.js 내장 타입
    
- 2-12. SSR 2. 실습
    
    getServerSideProps에 context: GetServerSidePropsContext를 매개변수로 사용하면 쿼리 스트링, URL 파라미터 등을 사용할 수 있음
    
- 2-13. SSG 1. 소개
    
    SSR은 페이지 내부의 데이터를 항상 최신 상태로 유지할 수 있지만, 사전 렌더링 시 API 호출이 지연되는 경우 페이지 표시가 지연될 수 있음.
    
    정적 사이트 생성(Static Site Generation) : SSR의 단점을 해결하는 사전 렌더링 방식. 빌드 타임에 페이지를 미리 사전 렌더링 → 빌드 때 이루어지기 때문에 사용자가 알 수 없음
    
    ⇒ 페이지 요청이 들어오면 즉시 빌드 시 사전 렌더링 된 HTML을 전송해 빠르게 화면을 표시할 수 있음 → 이후 JS 번들을 받으면 Hydration 진행
    
    - 단점 : 빌드 시에만 사전 렌더링이 이루어지기 때문에 최신 데이터 반영은 어려움 ⇒ 데이터가 자주 업데이트 되지 않는 정적인 페이지에 적합
- 2-14. SSG 2. 정적 경로에 적용하기
    
    getStaticProps 함수를 통해 SSG 방식으로 사전 렌더링 가능, getServerSideProps와 동일하게 작동
    
    Next.js의 개발 모드에서는 수정 결과를 바로 화면에 반영하기 위해 요청을 받을 때마다 페이지를 사전 렌더링 → SSG를 확인하기 위해선 빌드 후 start 필요
    
    빌드 내용에서 각각의 페이지가 SSG인지 SSR인지 구별 가능 ⇒ 페이지에 사전 렌더링 함수가 없다면 기본적으로 SSG로 작동
    
    SSG는 빌드 타임에서 사전 렌더링이 진행되기 때문에 쿼리 스트링을 알 수 없음
    
- 2-15. SSG 3. 동적 경로에 적용하기
    
    동적 경로를 사용하는 페이지에서 SSG 방식을 사용하기 위해서는 getStaticPaths 함수가 필요 → 브라우저에서 URL 파라미터를 전달 받기 전에는 서버에서 알 수 없음 ⇒ 빌드 과정에서 존재할 수 있는 페이지의 경로를 설정해야 함
    
    URL 파라미터는 문자열로 명시해야 함
    
    fallback : 정의한 동적 경로에 존재하지 않는 페이지를 요청 받았을 때의 처리 방식
    
    - false : not found 페이지로 취급
- 2-16. SSG 4. 폴백옵션 설정하기
    
    fallback : 정의한 동적 경로에 존재하지 않는 페이지를 요청 받았을 때의 처리 방식
    
    - blocking : SSR 방식처럼 요청된 페이지를 즉시 생성 → 이후 생성된 페이지는 서버에 자동으로 캐싱됨. ⇒ 페이지의 생성 시간이 길어지게 될 경우 로딩이 발생하게 됨
    - true : getStaticProps 함수의 반환값인 Props가 없는 페이지를 일단 반환 → Props 계산 후 따로 반환
    
    router.isFallback : 현재 페이지가 fallback 처리 중인지를 확인
    
    getStaticProps에 { notFound: true }를 반환하게 되면 
    
- 2-17. ISR 1. 소개 및 실습
    
    SSG는 사용자가 빠르게 서버에서 생성된 정적 페이지를 확인할 수 있지만, 최신 데이터를 확인할 수 없다는 단점이 존재 ⇒ ISR 사용
    
    ISR(Incremental Static Regeneration) : 증분 정적 재생성. SSG 방식으로 생성된 정적 페이지를 일정 시간을 주기로 다시 생성하는 기술.
    
    빌드 시에 생성된 정적인 페이지에 유통기한을 설정 → 유통기한이 지난 뒤 요청이 들어오면, 이전 정적 페이지를 반환 후 서버는 페이지를 다시 생성 → 이후의 요청에 업데이트 된 페이지를 반환
    
    만들어진 페이지를 반환하기 때문에 빠르게 응답할 수 있음(SSG의 장점) + 주기적인 업데이트를 통해 최신 데이터 반영 가능(SSR의 장점) ⇒ 가장 추천하는 방식
    
- 2-18. ISR 2. 주문형 재검증
    
    ISR을 적용하기 어려운 페이지 : 시간과 관계없이 사용자의 행동에 따라 데이터가 업데이트 되는 페이지(예를 들어, 게시글이 수정이 이루어지는 게시판 등)
    
    최신 데이터를 받아볼 수 없는 상황이 생기거나, 불필요한 페이지 재생성이 일어날 수 있음
    
    요청을 기반으로 페이지를 다시 생성하는 ISR ⇒ On-Demand ISR
    
    revalidation을 통해 페이지를 재생성할 수 있음
    
- 2-19. SEO 설정하기
    
    Next.js의 Head 컴포넌트를 통해 페이지 별 메타 태그를 설정할 수 있음
    
    동적 경로 페이지의 경우 fallback이 끝나기 전까지 메타 태그에 값이 없어 SEO 설정이 되지 않는 문제가 발생 → 따라서 fallback일 경우에도 기본적인 메타 태그를 return하게 설정해주어야 함
    
- 2-21 페이지 라우터 정리
    
    페이지 라우터의 장점
    
    - 파일 시스템 기반의 간편한 페이지 라우팅 제공: 동적 경로, Catch All Segment 등의 기능을 추가적인 코드 작성 없이 폴더 구조와 파일명으로 라우팅 설정 가능
    - 다양한 방식의 사전 렌더링 제공 : CSR의 느린 FCP 개선을 위해 사전 렌더링을 통해 서버에서 HTML을 렌더링 후 전송 → 빠른 화면 표시. 페이지 요청 시마다 페이지를 렌더링 해 반환하는 SSR / 빌드 타임에 정적 페이지를 생성해 응답 속도를 개선한 SSG / 빠른 응답 속도를 가진 SSG의 장점과 최신 데이터를 반영할 수 있는 SSR의 장점을 합친 ISR 방식 제공
    
    페이지 라우터의 단점
    
    - 페이지별 레이아웃 설정이 번거로움 : getLayout 메서드 추가 과정이 번거롭고 코드 중복 발생
    - 데이터 페칭이 페이지 컴포넌트에 집중 : 데이터를 index 페이지에서 get…Props 함수를 통해 불러와 전달했기 때문에, 자식 컴포넌트에 데이터를 전달하는 것이 번거로울 수 있음
    - 불필요한 컴포넌트들도 JS 번들에 포함 : 초기 화면 렌더링 후 JS 번들을 가져오는 과정에서 상호작용에 참여하지 않는(Hydration이 필요하지 않은) 컴포넌트의 코드도 포함되어 전달됨 ⇒ Hydration이 완료되기까지의 시간이 길어짐
    
    Link 컴포넌트는 상호작용이 아닌가? ⇒ Next.js의 Link 컴포넌트는 a 태그를 통해 구현되었기 때문에 기본적인 HTML의 기능만을 사용해 상호작용으로 취급되지 않음
    

- 3-1. App Router 시작하기
    
    Next.js 13 버전에 새롭게 추가된 라우터. Page Router를 완전히 대체. 라우팅, 레이아웃 설정, 데이터 페칭 방식 변경. 리액트 서버 컴포넌트와 스트리밍 기능도 사용 가능.
    
    네비게이팅, 프리페칭, 사전 렌더링 등은 대부분 비슷하게 유지됨.
    
    page.tsx - 페이지 역할 / layout.tsx - 레이아웃 역할
    
- 3-2. 페이지 라우팅 설정하기
    
    app 폴더의 구조를 기반으로 라우팅 설정
    
    page.tsx 파일만 페이지로 간주. 폴더명을 통해 페이지 경로명 정의
    
    App Router에서는 URL 파라미터나 쿼리 스트링의 경우 페이지의 props로 전달됨
    
    서버 컴포넌트의 경우 서버 측에서 사전 렌더링을 위해서만 실행되기 때문에, async를 사용해서 비동기적으로 작동하게 할 수 있음
    
- 3-3. 레이아웃 설정하기
    
    layout.tsx 파일 생성 시 페이지의 레이아웃으로 작동되어, 레이아웃 렌더링 후 children으로 페이지 렌더링
    
    위치하고 있는 곳 뿐만 아닌 하위 모든 페이지의 레이아웃으로 작동
    
    RootLayout 파일은 HTML의 틀을 정의하기 때문에 항상 존재해야 함
    
    라우트 그룹 : 경로 상에 아무 영향을 주지 않으며 각기 다른 경로의 파일들을 묶을 수 있는 폴더. (그룹명) 으로 설정. 공통된 레이아웃을 적용하는 데에 사용
    
- 3-4. 리액트 서버 컴포넌트 이해하기
    
    React 18v에서 새롭게 추가된, 새로운 유형의 컴포넌트. 서버측에서만 실행되는 컴포넌트 (브라우저에서 실행 X)
    
    사전 렌더링 이후 JS 번들로 전달이 된 리액트 컴포넌트는 Hydration을 위해 사전 렌더링 이후 한 번 더 실행됨 → Page Router 방식에서는 상호작용이 필요 없는 컴포넌트까지 JS 번들에 포함되어 모두 Hydration이 일어남
    
    ⇒ React Server Component 등장 : JS 번들에 상호작용이 일어나는 클라이언트 컴포넌트만 포함시켜 TTI를 줄일 수 있음
    
    Next.js는 페이지의 대부분을 서버 컴포넌트 구성하고, 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용할 것을 권장
    
    서버 컴포넌트의 내용이 클라이언트에 전달되지 않기 때문에 보안이 우수함
    
    기본적으로 컴포넌트는 서버 컴포넌트로 설정되며, “use client” 디렉티브를 통해 클라이언트 컴포넌트로 설정할 수 있음
    
- 3-5. 리액트 서버 컴포넌트 주의사항
    1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다
        
        useState, useEffect 등이나, onClick 등의 이벤트 핸들러, 브라우저에서 실행되는 라이브러리 등은 서버 컴포넌트에서 사용할 수 없음
        
    2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다
        
        클라이언트 컴포넌트도 사전 렌더링 과정에서 한번 실행된 뒤, JS 번들로 전달되어 Hydration 과정에서 한번 더 실행됨
        
    3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import할 수 없다
        
        클라이언트 컴포넌트 (서버 + 브라우저에서 실행) > 서버 컴포넌트 (서버에서만 실행) ⇒ 클라이언트에서 실행될 때, import 된 서버 컴포넌트의 코드는 전달되지 않기 때문에 사용하면 안됨.
        
        하지만 오류를 발생시키지는 않고, import된 서버 컴포넌트를 클라이언트 컴포넌트로 변경함
        
        * 클라이언트 컴포넌트에 children으로 서버 컴포넌트를 넘겨주는 경우 서버 컴포넌트를 클라이언트 컴포넌트로 변경하지 않음
        
    4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다
        
        직렬화(Serialization) : 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 형태(문자열, Byte)로 변환하는 것
        
        함수는 직렬화가 불가능
        
        사전 렌더링 과정에서 서버 컴포넌트가 클라이언트 컴포넌트보다 먼저 실행됨 → 서버 컴포넌트를 직렬화한 RSC Payload가 생성됨 (서버 컴포넌트의 렌더링 결과, 연결된 클라이언트 컴포넌트의 위치, 클라이언트 컴포넌트에게 전달되는 Props의 값을 포함) ⇒ RSC Payload로 변환될 때 함수와 같이 직렬화가 불가능한 Props를 직렬화할 수 없음
        
- 3-6. 네비게이팅
    
    페이지 이동은 Page Router와 동일하게 CSR 방식으로 작동
    
    프리페칭 과정에서 App Router는 JS 번들과 함께 RSC Payload도 함께 전송 → 서버 컴포넌트가 누락되면 페이지 이동 시 페이지를 구성할 수 없기 때문
    
    동적 페이지의 경우 SSR 방식으로 요청을 받을 때마다 페이지를 동적으로 생성하기 때문에 Prefetching 단계에서 JS 번들이 전달되지 않음
    
    기본적으로 Static 페이지 / URL 파라미터나 쿼리 스트링 등을 사용하는 등 정적인 페이지로 작동하기 어려운 페이지들은 자동으로 Dynamic 페이지로 빌드
    

- 4-1. 앱 라우터의 데이터 페칭
    
    서버 컴포넌트는 서버에서만 실행되기 때문에 비동기 함수로 설정 후 데이터 페칭이 일어나도 문제가 없음
    
    “데이터는 필요한 곳에서 직접 불러와라”
    
    환경변수 앞에 NEXT_PUBLIC_ 이 필요한 이유 : 없으면 서버 측에서만 사용할 수 있는 Private 변수로 설정됨 ⇒ 클라이언트 컴포넌트에서 접근이 불가능함
    
- 4-2. 데이터 캐시
    
    Fetch 메서드를 활용해 불러온 데이터를 Next 서버에서 보관하는 기능. 영구적으로 데이터를 보관하거나, 특정 시간을 주기로 갱신시키는 것이 가능 ⇒ 불필요한 데이터 요청의 수를 줄여서 웹 서비스의 성능을 개선할 수 있음
    
    fetch 메서드의 두 번째 인수로 적용 가능
    
    예) { cache: “force-cache” } - 요청의 결과를 무조건 캐싱. 한번 호출된 이후에 다시는 호출되지 않음
    
    - cache: no-store(기본값) : 데이터 페칭의 결과를 저장하지 않는 옵션. 캐싱을 아예 하지 않도록 설정하는 옵션 ⇒ 사전 렌더링 과정에서 데이터 캐시를 거치지 않고 백엔드 서버에게 항상 데이터를 요청함
    - cache: force-cache : 요청의 결과를 무조건 캐싱함 ⇒ 한번 호출된 이후에는 다시는 호출되지 않음
    - next: { revalidate: 3 } : 특정 시간을 주기로 캐시를 업데이트함. Page Router의 ISR 방식과 유사. 정해진 시간 이후 데이터를 STALE 상태로 설정 → STALE 상태 데이터를 응답 후 최신 데이터로 업데이트 → 이후 요청에 최신 데이터를 반환
    - next: { tags: [”a”] } : On-Demand Revalidate 방식. 요청이 들어왔을 때 데이터를 최신화 함
- 4-3. 리퀘스트 메모이제이션
    
    요청을 기억하는 것 ⇒ 다양한 컴포넌트에서 이뤄지는 요청들 중 중복되는 것을, 캐싱을 통해 한 번만 요청하게 하는 최적화 방법
    
    리퀘스트 메모이제이션 캐시에 동일한 요청에 대한 값이 있다면, 데이터 캐시나 백엔드 서버에 요청하지 않고 값을 반환함
    
    하나의 페이지를 렌더링 하는 동안에 중복된 API 요청을 캐싱하기 위해 존재하기 때문에, 렌더링이 종료되면 모든 캐시가 소멸됨
    
    ↔ 반면 데이터 캐시에 저장된 데이터는 서버가 중단되기 전까지 거의 영구적으로 보관됨
    
    서버 컴포넌트의 도입 때문에 데이터 페칭의 패턴이 변화했기 때문. (Page)페이지 컴포넌트에서 자식에게 Props로 넘겨주는 패턴 → (App)컴포넌트별로 데이터를 페칭 ⇒ 서로 다른 컴포넌트에서 동일한 데이터를 페칭하는 경우가 발생
    

- 5-1. 풀 라우트 캐시 1
    
    Next 서버측에서 빌드 타임에 특정 페이지의 렌더링 결과를 캐싱하는 기능 ⇒ SSG와 유사
    
    Dynamic Page로 설정되는 기준 : 특정 페이지가 접속 요청을 받을 때마다 매번 변화가 생기거나, 데이터가 달라질 경우 *서버 컴포넌트만 해당
    
    - 캐시되지 않는 Data Fetching을 사용할 경우 : cache 옵션이 없거나 no-store인 경우 페이지의 정보를 매번 요청해야 하기 때문에 캐싱하지 않음
    - 동적 함수(쿠키, 헤더, 쿼리스트링)을 사용하는 컴포넌트가 있을 때
    
    Dynamic Page가 아니라면 기본으로 Static Page로 설정되며, 풀 라우트 캐시가 적용됨
    
    풀 라우트 캐시의 경우에도 revalidate가 가능. 페이지의 요청에 revalidation이 설정되어 있는 경우, 데이터 캐시뿐만 아닌 풀 라우트 캐시도 함께 갱신됨. 데이터가 상해도 일단 캐싱된 데이터를 반환 후 최신 데이터로 업데이트 ⇒ ISR과 유사
    
- 5-2. 풀 라우트 캐시 2
    
    <Suspense>로 감싸게 되면 그 안의 컴포넌트는 사전 렌더링 과정에서 배제되고 오직 클라이언트 측에서만 렌더링됨
    
    내부 컴포넌트의 비동기 작업이 완료될 때까지 미완성 상태로 남겨두고 fallback을 표시했다가 완료된 컴포넌트를 표시함
    
    페이지에 캐시되지 않는 데이터 페칭이나 동적 함수를 사용하지 않는다면 페이지가 Static Page가 되어 빌드 과정에서 서버에 저장되게 됨
    
- 5-3. 풀 라우트 캐시 3. 동적 경로에 적용하기
    
    쿼리 스트링을 사용하는 경우 어떤 값이 들어갈지 모르기 때문에 풀 라우트 캐시는 사용할 수 없음 → 데이터 캐싱으로 성능 개선
    
    export function generateStaticParams() { return [{ id: "1" }, { id: "2" }, { id: "3" }]; } 와 같이 빌드 타임에 동적 경로에 어떤 값이 들어갈 수 있는지 명시해 정적 페이지를 생성할 수 있음. *문자열 데이터로만 명시. 캐시하지 않고 데이터를 페칭하는 경우에도 강제로 Static 페이지로 설정됨 ⇒ getStaticPaths와 유사.
    
    return하지 않은 경로의 경우 Dynamic 페이지로 생성 후 페이지를 풀 라우트 캐시로 저장
    
    notFound() : 404 페이지로 리다이렉션하는 next/navigation의 메서드
    
    export const dynamicParams = false; 로 설정하면 generateStaticParams에 포함되지 않은 경로에 접근 시 404 페이지로 이동시킴
    
- 5-4. 라우트 세그먼트 옵션
    
    라우트 세그먼트 옵션 : 특정 페이지에 dynamicParams 등과 같이 약속된 이름의 변수를 선언하고 값을 설정해 export함으로써 페이지의 설정을 강제로 조정할 수 있는 기능
    
    export const dynamic = “” : 특정 페이지의 유형을 강제로 Static, Dynamic 페이지로 설정
    
    - auto : 기본값, 아무 것도 강제하지 않음
    - force-dynamic : 페이지를 강제로 Dynamic 페이지로 설정
    - force-static : 페이지를 강제로 Static 페이지로 설정. no-store로 설정된 페칭 함수는 강제로 데이터를 캐싱하고, 동적 함수는 undefined를 반환함
    - error : 페이지를 강제로 Static 페이지로 설정하지만 Static으로 설정하면 안될 때는 빌드 오류를 발생시킴
- 5-5. 클라이언트 라우터 캐시
    
    클라이언트 라우터 캐시 : 브라우저에 저장되는 캐시. 페이지 이동을 효율적으로 진행하기 위해 일부 데이터를 보관함
    
    페이지 이동이 일어나면 공유된 컴포넌트(RSC Payload에 공통적으로 포함된 layout 등의 서버 컴포넌트)를 중복되게 렌더링 ⇒ 클라이언트 라우터 캐시가 레이아웃을 캐싱
    
    클라이언트 라우터 캐시는 새로고침 시 초기화 됨
    

- 6-1. 스트리밍이란?
    
    큰 용량의 동영상을 아주 빠른 속도로 시청할 수 있게 해주는 기술. 서버에서 클라이언트로 데이터를 보낼 때, 데이터의 용량이 크거나 클라이언트에서 준비하는 데에 오랜 시간이 걸릴 때 데이터를 여러 조각으로 쪼개 전송하는 기술 ⇒ 모든 데이터가 준비되지 않더라도 지금까지 전달받은 데이터에 접근할 수 있음
    
    Next.js는 HTML 스트리밍 기능을 자체적으로 제공 → 렌더링이 오래 걸리는 컴포넌트는 대체 UI를 보여주고 로딩 완료 후 표시
    
    ⇒ Dynamic 페이지에 주로 활용 → Dynamic 페이지는 풀 라우트 캐시의 이점을 활용할 수 없기 때문에, API 호출에 오랜 시간이 걸릴 경우 사용자 경험이 저하될 수 있음
    
- 6-2. 스트리밍 1. 페이지 스트리밍 적용하기
    
    페이지를 스트리밍으로 설정하려면 동일한 경로에 loading.tsx 페이지를 생성 후 대체 UI를 만들면 됨
    
    주의점
    
    - layout과 같이 동일한 경로에만 적용되는 것이 아닌 하위 비동기 페이지에 전부 적용됨
    - loading.tsx는 모든 페이지 컴포넌트가 아닌 비동기 페이지 컴포넌트에만 적용됨
    - loading.tsx는 페이지 컴포넌트에만 스트리밍을 적용할 수 있음
    - 브라우저에서 쿼리 스트링이 변경될 때에는 트리거되지 않음 ⇒ Suspense 컴포넌트를 사용해야 함
- 6-3. 스트리밍 2. 컴포넌트 스트리밍 적용하기
    
    Suspense 컴포넌트로 감싸진 컴포넌트는 스트리밍이 적용됨. Suspense의 fallback props로 대체 UI를 전달하면 내부 컴포넌트 렌더링 전에 표시됨
    
    Suspense에 key값을 주어 key가 변경될 때마다 대체 UI가 표시되게 설정할 수 있음
    
    여러 컴포넌트를 비동기적으로 스트리밍할 때 유용함 → Suspense를 사용하지 않는다면 모든 컴포넌트의 렌더링이 끝난 뒤에야 화면이 표시됨 ⇒ Suspense를 사용하면 일단 화면이 표시된 후 렌더링이 끝난 컴포넌트를 표시함
    
- 6-4. 스켈레톤 UI 적용하기
    
    스켈레톤 UI : 뼈대 역할을 하는 UI. 로딩 전에 사용자에게 대략적인 UI 제공
    
    React Loading Skeleton 등과 같은 라이브러리도 있음
    
- 6-5. 에러 핸들링
    
    기존의 에러 핸들링 : try-catch문을 이용한 에러 핸들링 → 데이터 페칭이 일어나는 모든 곳에서 에러 핸들링이 필요함
    
    ⇒ error.tsx 파일을 사용해서 특정 경로에서 일어나는 에러를 한번에 처리. 에러 파일을 생성하면, 에러 파일과 동일하거나 하위에 있는 경로의 페이지에서 오류가 발생할 경우 페이지 컴포넌트 대신 에러 컴포넌트가 표시됨
    
    에러는 서버와 클라이언트 모든 곳에서 발생할 수 있기 때문에, error.tsx 파일은 “use client”를 사용해서 클라이언트 컴포넌트로 만들어야 함
    
    에러 컴포넌트의 props
    
    - error : Error : 에러의 내용을 담고 있음
    - reset : () ⇒ void : 에러를 발생한 페이지를 복구하기 위해서, 에러 상태를 초기화 후 다시 한 번 컴포넌트 렌더링을 시도. * 클라이언트 측에서 이전에 서버로부터 전달받은 데이터를 이용해서 단순히 다시 한 번 렌더링 해보는 메소드 → 서버 컴포넌트를 다시 실행하지 않아 데이터 페칭이 다시 일어나지는 않음
    
    useRouter().refresh() : 현재 페이지에 필요한 서버 컴포넌트를 서버 측에서 다시 렌더링 후 RSC 페이로드를 전달받는 메소드.
    
    startTransition(() ⇒ {}) : 인수로 전달 받은 콜백 함수 안에 들어있는 UI를 변경시키는 작업을 일괄적으로 처리해주는 리액트 컴포넌트 ⇒ refresh와 reset을 넣어 하나의 작업처럼 작동하게 함
    
    주의점 : 에러가 발생해서 error.tsx가 렌더링 된다면, 현재 위치하고 있는 레벨의 layout까지만 표시함 ⇒ 하위 레이아웃 및 컴포넌트가 렌더링 되지 않을 수 있음
    

- 7-1. 서버 액션
    
    서버 액션 : 브라우저에서 호출할 수 있는 서버에서 실행되는 비동기 함수
    
    함수 내에 “use server” 디렉티브를 통해 서버 액션으로 설정. 클라이언트 브라우저 측에서 form이 제출이 발생했을 때 서버 측에서 사용되는 함수를 실행할 수 있게 해줌. <form action={action>과 같이 사용.
    
    서버 액션을 만들면 자동으로 API가 하나 생성이 되고, form 태그가 제출되었을 때 자동으로 호출됨.
    
    form 내의 데이터는 input에 설정된 name 값으로 서버 액션 함수에 FormData 형식의 매개변수로 전달됨
    
    가져온 데이터의 타입은 FormDataEntryValue | null이기 때문에 타입 안정성을 보장받기 위해 formData.get("content")?.toString(); 와 같이 타입 변환을 해주면 좋음
    
    서버 액션을 사용하는 이유 : 코드가 간결해짐. 서버 측에서만 실행되고 브라우저는 호출밖에 할 수 없기 때문에 보안이 필요한 경우 유용함.
    
- 7-2. 리뷰 추가 기능 구현하기
    
    서버 액션 함수를 별도의 파일로 분리하는 경우, 함수 내부가 아닌 파일의 최상단에 “use server” 디렉티브를 추가해주어야 함
    
    추가적인 데이터가 formData로 전달되어야 하는 경우, <input name="bookId" value={bookId} hidden readonly />와 같이 숨겨진 input으로 값만 전달해줄 수 있음
    
- 7-4. 리뷰 재검증 구현하기
    
    revalidatePath(페이지 경로) : 인수로 전달 받은 페이지를 재검증 하여 페이지를 새로 생성 후 보내줌 ⇒ 댓글 추가 등에서 사용 가능
    
    주의점
    
    - 서버 측에서만 호출할 수 있음 ⇒ 서버 컴포넌트에서만 사용 가능
    - 전달된 페이지에 포함된 모든 캐시까지 전부 다 무효화(삭제, PURGE) 시킴 ⇒ 풀 라우트 캐시까지 삭제됨(하지만 새로운 데이터를 저장해주지는 않음 → 다음 요청 시 갱신)
- 7-5. 다양한 재검증 방식 살펴보기
    
    revalidate()의 방식
    
    - 특정 주소에 해당하는 페이지만 재검증 : revalidatePath(”페이지 경로”);
    - 특정 경로의 모든 동적 페이지를 재검증 : revalidatePath(”/페이지 경로/[동적 경로]”, “page”);
    - 특정 레이아웃을 갖는 모든 페이지 재검증 : revalidatePath(”/(라우트 그룹)”, “layout”);
    - 모든 데이터 재검증 : revalidatePath(”/”, “layout”);
    - 태그를 기준으로 데이터 캐시 재검증 : revalidateTag(”태그명”); ⇒ 페이지 전체를 재검증 하지 않기 때문에, 불필요한 재검증이 일어나지 않게 할 수 있음
- 7-6. 클라이언트 컴포넌트에서의 서버 액션
    
    const [state, formAction, isPending] = useActionState(서버 액션 함수, 초기값)
    
    useActionState를 사용하면 서버 액션 함수의 첫 번째 인수로 state가 전달됨
    
- 7-7. 리뷰 삭제 기능 구현하기
    
    formRef.current?.submit() / formRef.current?.requestSubmit() : submit은 유효성 검사나 이벤트 핸들러 등을 무시하고 강제로 폼의 제출을 발생시키기 때문에 위험함 / requestSubmit은 사용자가 submit 버튼을 누른 것과 동일하게 작동함
    

- 8-1. 페럴렐 라우트(병렬 라우트)
    
    하나의 화면 안에 여러 개의 페이지를 병렬로 렌더링 시켜주는 패턴
    
    슬롯 : 병렬로 렌더링이 될 하나의 페이지 컴포넌트를 보관하는 폴더(경로에 영향을 주지 않음) → 슬롯 내의 페이지 컴포넌트는 부모의 레이아웃 컴포넌트에 props로 전달됨
    
    슬롯의 개수는 제한이 없음
    
    슬롯 내부에 새로운 경로를 생성할 수 있음 → 경로가 설정된 슬롯의 내용만 변경됨
    
    주의점
    
    - 링크 컴포넌트를 이용해서 클라이언트 사이드 렌더링 방식으로 페이지 이동 시에만 하위 경로에 접속할 수 있음 → 직접 접근 시 children이나 경로가 없는 slot들의 내용을 할 수 없기 때문 ⇒ default 페이지를 만들어 404 에러를 방지
- 8-2. 인터셉팅 라우트
    
    사용자가 특정 경로로 접속했을 경우, 요청을 가로채서 다른 원하는 페이지를 대신 렌더링하도록 설정하는 라우팅 패턴. 인스타그램의 게시글을 모달 형태로 띄우는 등에서 사용됨
    
    초기 접속 요청이 아닌 CSR 방식(Link, router.push 등)으로 접속 시 인터셉트 발생
    
    원하는 경로 폴더명 앞에 (상대경로)를 입력해 인터셉트 페이지로 설정할 수 있음.
    
    예시)
    
    - book ⇒ 동일한 위치에 있는 book 페이지를 인터셉팅
    - (..)book ⇒ 상위 경로에 있는 book 페이지를 인터셉팅
    - (..)(..)book ⇒ 두 단계 경로 위에 있는 경우.
    - (…)book ⇒ app 폴더 바로 아래에 있는 경로를 인터셉팅
    
    intercept 페이지에서 props를 통해 기존 페이지에 전달될 props를 전달받을 수 있음
    
    모달 요소는 createPortal을 통해 특정 페이지의 하위에 렌더링되는 것이 아닌 원하는 위치(최상위 레이아웃 등)에 표시될 수 있도록 하는 것이 좋음
    

- 9-1. 이미지 최적화
    
    평균적으로 이미지가 웹페이지의 용량을 가장 많이 차지 함 → 파일 형식 변환, 디바이스 사이즈에 맞는 이미지 불러오기, 레이지 로딩, 블러 이미지 사용 등의 이미지 최적화가 필요함 ⇒ Next.js는 자체적으로 이러한 기능을 Image 컴포넌트로 제공함
    
    Next.js의 Image 컴포넌트의 기능
    
    - 이미지의 형식을 webP로 변환
    - 현재 화면에 렌더링 되어야 할 이미지만 로딩 ⇒ 레이지 로딩
    - 브라우저의 크기에 맞게 이미지 제공
    
    외부 서버의 이미지를 사용하는 경우 next.config.ts 파일에 명시해주어야 함
    
- 9-2. 검색 엔진 최적화 (SEO)
    
    검색 엔진이 페이지에 어떠한 정보들이 있는지 더 잘 수집할 수 있게 설정해 검색 결과에 더 잘 노출되도록 하는 기술
    
    Sitemap 설정, RSS 발행, 시멘틱 태그 설정, 메타 데이터 설정하기 등의 방법으로 최적화 가능
    
    export const metadata : Metadata ⇒ Next.js에서의 메타 데이터 설정. title, description, openGraph 등을 설정할 수 있음
    
    동적인 데이터를 사용해 메타 데이터를 설정해야 하는 경우 export function generateMetadata({ 동적 데이터 }) { return {} } 을 사용 ⇒ Page와 동일한 props를 전달받아 return 값으로 Metadata를 반환할 수 있음
    
    generateMetadata 안에서 데이터 페칭 후 metadata로 활용할 수도 있음 *중복된 데이터 페칭은 리퀘스트 메모이제이션을 통해 최적화됨
    
- 9-4. 배포 후 최적화
    
    Vercel 프로젝트의 Setting-Functions에서 리전 설정을 통해 더 빠른 지역을 설정할 수 있음
